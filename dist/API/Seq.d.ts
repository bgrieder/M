import { Iterable } from './Iterable';
import { Monad } from './Monad';
export interface Seq<A> extends Monad<A> {
    isCaching: boolean;
    useCache(): void;
    disableCache(): void;
    isEmpty(): boolean;
    map<U>(f: (value: A) => U): Seq<U>;
    filter(f: (value: A) => boolean): Seq<A>;
    filterNot(f: (value: A) => boolean): Seq<A>;
    flatten<U>(): Seq<U>;
    flatMap<U>(f: (value: A) => Seq<U>): Seq<U>;
    size(): number;
    reverse(): Seq<A>;
    takeFirst(n: number): Seq<A>;
    take(n: number): Seq<A>;
    takeLast(n: number): Seq<A>;
    takeAt(index: number): A;
    apply(index: number): A;
    takeAtOrElse(index: number, elseVal: (index: number) => A): A;
    applyOrElse(index: number, elseVal: (index: number) => A): A;
    concat(it: Iterable<A>): Seq<A>;
    prepend(a: A): Seq<A>;
    append(a: A): Seq<A>;
    push(a: A): Seq<A>;
    contains(value: A): boolean;
    indexOf(value: A): number;
    exists(test: (value: A) => boolean): boolean;
    corresponds<B>(other: Seq<B>, test: (thisVal: A, otherVal: B) => boolean): boolean;
    count(test: (value: A) => boolean): number;
    dropFirst(n: number): Seq<A>;
    dropLast(n: number): Seq<A>;
    dropWhile(test: (value: A) => boolean): Seq<A>;
    dropAt(...indexes: number[]): Seq<A>;
    difference(other: Seq<A>): Seq<A>;
    diff(other: Seq<A>): Seq<A>;
    distinct(): Seq<A>;
    endsWith(it: Iterable<A>): boolean;
    startsWith(it: Iterable<A>): boolean;
    slice(from?: number, until?: number): Seq<A>;
}
