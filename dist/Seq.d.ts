import { Iterator } from './API/Iterator';
import { Iterable } from './API/Iterable';
import { Seq } from './API/Seq';
import { IterableImpl } from './Iterable';
export declare class SeqImpl<A> extends IterableImpl<A> implements Seq<A> {
    static caching: boolean;
    protected _isCaching: boolean;
    private _isForward;
    private _isBackward;
    constructor(it: Iterable<A>, useCache?: boolean);
    protected newInstance<U>(it: Iterable<U>, useCache?: boolean): Seq<U>;
    readonly isCaching: boolean;
    readonly isForward: boolean;
    readonly isBackward: boolean;
    useCache(): void;
    disableCache(): void;
    isEmpty(): boolean;
    map<U>(f: (value: A) => U): Seq<U>;
    filter(f: (value: A) => boolean): Seq<A>;
    filterNot(f: (value: A) => boolean): Seq<A>;
    flatten<U>(): Seq<U>;
    flatMap<U>(f: (value: A) => Seq<U>): Seq<U>;
    size(): number;
    protected _size(backward?: boolean): number;
    reverse(): Seq<A>;
    private _takeBuilder(n);
    takeFirst(n: number): Seq<A>;
    take: (n: number) => Seq<A>;
    takeLast(n: number): Seq<A>;
    takeAt(index: number): A;
    protected _takeAt(index: number): [boolean, A];
    apply: (index: number) => A;
    takeAtOrElse(index: number, elseVal: (index: number) => A): A;
    applyOrElse: (index: number, elseVal: (index: number) => A) => A;
    concat(it: Iterable<A>): Seq<A>;
    prepend(a: A): Seq<A>;
    append(a: A): Seq<A>;
    push: (a: A) => Seq<A>;
    contains(value: A): boolean;
    indexOf(value: A): number;
    exists(test: (value: A) => boolean): boolean;
    corresponds<B>(other: Seq<B>, test: (thisVal: A, otherVal: B) => boolean): boolean;
    count(test: (value: A) => boolean): number;
    private _dropBuilder(n);
    dropFirst(n: number): Seq<A>;
    dropLast(n: number): Seq<A>;
    dropWhile(test: (value: A) => boolean): Seq<A>;
    dropAt(...indexes: number[]): Seq<A>;
    difference(other: Seq<A>): Seq<A>;
    diff(other: Seq<A>): Seq<A>;
    distinct(): Seq<A>;
    private _startsEndsWith();
    endsWith(it: Iterable<A>): boolean;
    startsWith(it: Iterable<A>): boolean;
    slice(from?: number, until?: number): Seq<A>;
}
export declare function seq<A>(fit?: () => Iterator<A>, bit?: () => Iterator<A>, length?: number): Seq<A>;
export declare function fseq<A>(it: Iterable<A>): Seq<A>;
