"use strict";
require('source-map-support').install();
var chai = require("chai");
var TestsSetup_1 = require("./TestsSetup");
var IterableImpl_1 = require("../impl/IterableImpl");
var IteratorImpl_1 = require("../impl/IteratorImpl");
var SeqImpl_1 = require("../impl/SeqImpl");
var deepEqual = chai.assert.deepEqual;
var ok = chai.assert.ok;
describe('Seq', function () {
    before(function (done) {
        done();
    });
    after(function (done) {
        done();
    });
    beforeEach(TestsSetup_1._beforeEach);
    afterEach(TestsSetup_1._afterEach);
    it('should take multiple constructors', function (done) { return TestsSetup_1.checkFail(done, function () {
        deepEqual(SeqImpl_1.aseq().toArray(), [], "empty seq (mzero) can be constructed");
        deepEqual(SeqImpl_1.aseq().reverse().toArray(), [], "empty seq (mzero) can be constructed");
        deepEqual(SeqImpl_1.aseq(1).toArray(), [1], "seq can be constructed from a single value");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).toArray(), [1, 2, 3], "seq can be constructed from multiple values");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().toArray(), [1, 2, 3].reverse(), "seq can be constructed from multiple values and read backwards");
        deepEqual(SeqImpl_1.aseq(SeqImpl_1.aseq(1, 2, 3)).toArray()[0].toArray(), [1, 2, 3], "seq can contain other seqs");
    }); });
    it('should honor the Seq interface', function (done) { return TestsSetup_1.checkFail(done, function () {
        deepEqual(SeqImpl_1.aseq().size(), 0, "seq should have size 0");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).size(), 3, "seq should have size 3");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).map(function (x) { return x * x; }).toArray(), [1, 4, 9], "seq should map");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).map(function (x) { return x * x; }).reverse().toArray(), [1, 4, 9].reverse(), "seq should map");
        deepEqual(SeqImpl_1.aseq(SeqImpl_1.aseq(1, 2), SeqImpl_1.aseq(2, 3)).flatten().toArray(), [1, 2, 2, 3], "seq of seq should be flattened");
        deepEqual(SeqImpl_1.aseq(SeqImpl_1.aseq(1, 2), SeqImpl_1.aseq(2, 3)).flatten().reverse().toArray(), [1, 2, 2, 3].reverse(), "seq of seq should be flattened");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).flatten().toArray(), [1, 2, 3], "seq of non convertible values should not be flattened");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).flatMap(function (x) { return SeqImpl_1.aseq(0, x * x); }).toArray(), [0, 1, 0, 4, 0, 9], "seq should map");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).flatMap(function (x) { return SeqImpl_1.aseq(0, x * x); }).reverse().toArray(), [0, 1, 0, 4, 0, 9].reverse(), "seq should map");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).filter(function (x) { return x % 2 == 0; }).toArray(), [2, 4], "seq should filter");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).filter(function (x) { return x % 2 == 0; }).reverse().toArray(), [2, 4].reverse(), "seq should filter");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).filterNot(function (x) { return x % 2 == 0; }).toArray(), [1, 3, 5], "filterNot should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).filterNot(function (x) { return x % 2 == 0; }).reverse().toArray(), [1, 3, 5].reverse(), "filterNot should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).takeFirst(3).toArray(), [1, 2, 3], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).takeFirst(3).reverse().toArray(), [3, 2, 1], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).reverse().takeFirst(3).toArray(), [5, 4, 3], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).takeLast(3).toArray(), [3, 4, 5], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).takeLast(3).reverse().toArray(), [5, 4, 3], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5).reverse().takeLast(3).toArray(), [3, 2, 1], "take should take what is required");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).map(function (x) { return 2 * x; }).concat(SeqImpl_1.aseq(4, 5, 6).map(function (x) { return 3 * x; })).toArray(), [2, 4, 6, 12, 15, 18], "seq should concat(enate)");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).map(function (x) { return 2 * x; }).concat(SeqImpl_1.aseq(4, 5, 6).map(function (x) { return 3 * x; })).reverse().toArray(), [2, 4, 6, 12, 15, 18].reverse(), "seq should concat(enate)");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).prepend(0).toArray(), [0, 1, 2, 3], "elements can prepended");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).prepend(0).reverse().toArray(), [0, 1, 2, 3].reverse(), "elements can prepended");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).append(4).toArray(), [1, 2, 3, 4], "elements can appended");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).append(4).reverse().toArray(), [1, 2, 3, 4].reverse(), "elements can appended");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).push(4).toArray(), [1, 2, 3, 4], "elements can pushed");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).push(4).reverse().toArray(), [1, 2, 3, 4].reverse(), "elements can pushed");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).takeAt(2), 3, "elements can be retrieved");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().takeAt(2), 1, "elements can be retrieved");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).apply(0), 1, "elements can be retrieved");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().apply(2), 1, "elements can be retrieved");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).takeAtOrElse(2, function () { return 0; }), 3, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().takeAtOrElse(2, function () { return 0; }), 1, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).takeAtOrElse(4, function () { return 0; }), 0, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().takeAtOrElse(4, function () { return 0; }), 0, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).applyOrElse(2, function () { return 0; }), 3, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().applyOrElse(2, function () { return 0; }), 1, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).applyOrElse(4, function () { return 0; }), 0, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().applyOrElse(4, function () { return 0; }), 0, "elements can be retrieved with getAtr");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).contains(3), true, "contains should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).contains(4), false, "contains should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().contains(3), true, "contains should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).reverse().contains(4), false, "contains should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).indexOf(3), 2, "indexOf should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).indexOf(4), -1, "indexOf should work");
        ok(SeqImpl_1.aseq(1, 2, 3).equals(SeqImpl_1.aseq(1, 2, 3)), "equals should work");
        ok(!SeqImpl_1.aseq(1, 2, 3).equals(SeqImpl_1.aseq(3, 2, 1)), "equals should work");
        ok(SeqImpl_1.aseq(SeqImpl_1.aseq(1, 2, 3), SeqImpl_1.aseq(1, 2, 3)).equals(SeqImpl_1.aseq(SeqImpl_1.aseq(1, 2, 3), SeqImpl_1.aseq(1, 2, 3))), "equals should work");
        ok(SeqImpl_1.aseq(1, 2, 3).exists(function (x) { return x === 2; }), "exists should work");
        ok(!SeqImpl_1.aseq(1, 2, 3).exists(function (x) { return x === 4; }), "exists should work");
        ok(SeqImpl_1.aseq(1, 2, 3).corresponds(SeqImpl_1.aseq(2, 4, 6), function (a, b) { return b === 2 * a; }), "corresponds should work");
        ok(!SeqImpl_1.aseq(1, 2, 3).corresponds(SeqImpl_1.aseq(2, 4, 6), function (a, b) { return b === 3 * a; }), "corresponds should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).count(function (x) { return x % 2 === 0; }), 1, "count should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).count(function (x) { return x === 4; }), 0, "count should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(2).toArray(), [3, 4, 5, 1, 2, 6], "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(0).toArray(), [1, 2, 3, 4, 5, 1, 2, 6], "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(8).toArray(), [], "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(2).reverse().toArray(), [3, 4, 5, 1, 2, 6].reverse(), "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(0).reverse().toArray(), [1, 2, 3, 4, 5, 1, 2, 6].reverse(), "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropFirst(8).reverse().toArray(), [].reverse(), "drop should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(2).toArray(), [1, 2, 3, 4, 5, 1], "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(0).toArray(), [1, 2, 3, 4, 5, 1, 2, 6], "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(8).toArray(), [], "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(2).reverse().toArray(), [1, 2, 3, 4, 5, 1].reverse(), "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(0).reverse().toArray(), [1, 2, 3, 4, 5, 1, 2, 6].reverse(), "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropLast(8).reverse().toArray(), [].reverse(), "dropLast should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 3; }).toArray(), [3, 4, 5, 1, 2, 6], "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 0; }).toArray(), [1, 2, 3, 4, 5, 1, 2, 6], "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 8; }).toArray(), [], "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 3; }).reverse().toArray(), [3, 4, 5, 1, 2, 6].reverse(), "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 0; }).reverse().toArray(), [1, 2, 3, 4, 5, 1, 2, 6].reverse(), "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 5, 1, 2, 6).dropWhile(function (x) { return x < 8; }).reverse().toArray(), [].reverse(), "dropWhile should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(0, 5).toArray(), [1, 2, 3, 4], "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(1, 2).toArray(), [0, 3, 4, 5], "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(2, 2).toArray(), [0, 1, 3, 4, 5], "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(2, 7).toArray(), [0, 1, 3, 4, 5], "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(-1, 7).toArray(), [0, 1, 2, 3, 4, 5], "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(0, 5).reverse().toArray(), [1, 2, 3, 4].reverse(), "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(1, 2).reverse().toArray(), [0, 3, 4, 5].reverse(), "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(2, 2).reverse().toArray(), [0, 1, 3, 4, 5].reverse(), "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(2, 7).reverse().toArray(), [0, 1, 3, 4, 5].reverse(), "dropAt should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).dropAt(-1, 7).reverse().toArray(), [0, 1, 2, 3, 4, 5].reverse(), "dropAt should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1).difference(SeqImpl_1.aseq(1, 3)).toArray(), [2, 4], "difference should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1).difference(SeqImpl_1.aseq(1, 3)).reverse().toArray(), [2, 4].reverse(), "difference should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1, 2, 3).diff(SeqImpl_1.aseq(1, 2, 3)).toArray(), [4, 1, 2, 3], "diff should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1, 2, 3).diff(SeqImpl_1.aseq(1, 2, 3)).reverse().toArray(), [3, 2, 1, 4], "diff should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1, 2, 3).distinct().toArray(), [1, 2, 3, 4], "distinct should work");
        deepEqual(SeqImpl_1.aseq(1, 2, 3, 4, 1, 2, 3).distinct().reverse().toArray(), [1, 2, 3, 4].reverse(), "distinct should work");
        ok(SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).endsWith(SeqImpl_1.aseq(5, 6, 7)), "endsWith should work");
        ok(!SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).endsWith(SeqImpl_1.aseq(3, 4, 5)), "endsWith should work");
        ok(!SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).endsWith(SeqImpl_1.aseq(5, 6, 7, 1)), "endsWith should work");
        ok(SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).endsWith(SeqImpl_1.aseq()), "endsWith should work");
        ok(SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).startsWith(SeqImpl_1.aseq(1, 2, 3)), "startsWith should work");
        ok(!SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).startsWith(SeqImpl_1.aseq(3, 4, 5)), "startsWith should work");
        ok(!SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).startsWith(SeqImpl_1.aseq(1, 2, 3, 5)), "startsWith should work");
        ok(SeqImpl_1.aseq(1, 2, 3, 4, 5, 6, 7).startsWith(SeqImpl_1.aseq()), "startsWith should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(0).toArray(), [0, 1, 2, 3, 4, 5], "slice should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(2, 5).toArray(), [2, 3, 4], "slice should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(2, 15).toArray(), [2, 3, 4, 5], "slice should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(0).reverse().toArray(), [0, 1, 2, 3, 4, 5].reverse(), "slice should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(2, 5).reverse().toArray(), [2, 3, 4].reverse(), "slice should work");
        deepEqual(SeqImpl_1.aseq(0, 1, 2, 3, 4, 5).slice(2, 15).reverse().toArray(), [2, 3, 4, 5].reverse(), "slice should work");
        console.log("DONE");
    }); });
    it('.take() should iterate only what it needs', function (done) { return TestsSetup_1.checkFail(done, function () {
        var vals = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        var len = vals.length;
        var findex = -1;
        var bindex = -1;
        var fit = function () {
            var index = -1;
            return IteratorImpl_1.iterator(function () {
                ++findex;
                return (++index) < len;
            }, function () { return vals[index]; });
        };
        var bit = function () {
            var index = vals.length;
            return IteratorImpl_1.iterator(function () {
                ++bindex;
                return (--index >= 0);
            }, function () { return vals[index]; });
        };
        var s = SeqImpl_1.fseq(IterableImpl_1.iterable(fit, bit));
        var resf = s.takeFirst(8).takeFirst(6).takeFirst(3).toArray();
        deepEqual(resf, [1, 2, 3], "take should take the correct values");
        deepEqual(findex, 2, "take should only iterate what is needed");
        var resb = s.takeFirst(3).reverse().toArray();
        deepEqual(resb, [3, 2, 1], "take should take the correct values");
        deepEqual(bindex, 19, "take should only iterate what is needed");
    }); });
    it('should work lazily', function (done) { return TestsSetup_1.checkFail(done, function () {
        var l = SeqImpl_1.aseq(SeqImpl_1.aseq(1), SeqImpl_1.aseq(2, 3, 4, 5), SeqImpl_1.aseq(6, 7, 8, 9));
        var mapRun = 0;
        var filterRun = 0;
        var isOdd = function (x) {
            filterRun += 1;
            return x % 2 !== 0;
        };
        var square = function (x) {
            mapRun += 1;
            return x * x;
        };
        var lazyRes = l.flatten().filter(isOdd).map(square).takeFirst(2);
        deepEqual(filterRun, 0, "filter should not have run");
        deepEqual(mapRun, 0, "map should not have run");
        var res = lazyRes.toArray();
        deepEqual(res, [1, 9], "should calculate the correct result");
        deepEqual(filterRun, 3, "filter should run 3 times");
        deepEqual(mapRun, 2, "should run twice");
    }); });
    it('should behave like a gentle Monad', function (done) { return TestsSetup_1.checkFail(done, function () {
        var f = function (x) { return SeqImpl_1.aseq(x * x); };
        var g = function (x) { return SeqImpl_1.aseq(x + 2); };
        deepEqual(SeqImpl_1.aseq(3).flatMap(f).toArray(), f(3).toArray(), "1st Monad Law");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).flatMap(SeqImpl_1.aseq).toArray(), SeqImpl_1.aseq(1, 2, 3).toArray(), "2nd Monad Law");
        deepEqual(SeqImpl_1.aseq(1, 2, 3).flatMap(function (x) { return f(x).flatMap(g); }).toArray(), SeqImpl_1.aseq(1, 2, 3).flatMap(f).flatMap(g).toArray(), "3rd Monad Law");
    }); });
});
//# sourceMappingURL=Seq.test.js.map